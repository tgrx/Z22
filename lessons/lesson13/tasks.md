# Задание 13

---

Для задания надо создать отдельную ветку от свежего мастера.
После решения задач, файлы и тесты закоммитить,
ветку запушить, создать в Гитхабе пулл-реквест.

УСЛОВИЕ: в своей домашней папке

Создать питоновский пакет с названием "lesson13"

В пакете создать модуль с именем соответствущего уровня

В модуле написать код согласно заданию уровня

ПРИМЕР:

```
homeworks/alexander_sidorov/lesson13/
    __init__.py     # пакет!
    level01.py      # вот!
    level02.py      # вот!
    test_lev1.py
    test_lvl02.py
```

```python
# homeworks/alexander_sidorov/lesson13/level01.py

def do(x, y):
    ...

class Doer:
    pass
```

---


## Уровень 1

Модуль: `level01`

Создать функцию с названием `get_headers`.

Функция принимает на вход один аргумент.

Это будет строка с каким-то примером ответа HTTP.
То есть, содержимое не важно.
Имеет значение то, что
1) это строка,
2) это ответ HTTP (HTTP Response)
3) в котором, возможно, есть какие-то заголовки HTTP (HTTP headers)

Функция должна разобрать содержимое и вернуть dict.

Ключи - названия заголовков.

Значения - значения заголовков.

## Уровень 2

Модуль: `level02`

Создать функцию c названием `get_typed_headers`.

Функция должна работать так же,
как и `get_headers` из `level01`, с одним отличием:

Значения тех заголовков,
которые по смыслу имеют какой-то тип,
отличающийся от строки - например,
число или дата и время - должны быть именно этого типа.

Пример: заголовок "Date" предполагает, что его значение - дата и время.
Поэтому в результате в dict у этого ключа значение будет типа `datetime`.

Пример: заголовок "Content-Length" предполагает, что
его значение - это число, поэтому в результате в dict у такого ключа
значение будет типа `int`.

Если, конечно, такие заголовки будут присутствовать в переданном http response. 


## Уровень 3

Модуль: `level03`

Создать функцию с названием `make_headers`.

Поведение этой функции будет обратное поведению
функциям `level01.get_headers` и `level02.get_typed_headers`.

Иначе говоря, этой функции на вход будет передаваться dict с заголовками.

А она должна будет его преобразовать в строку, часть http response,
с правильным содержимым.

Числа, даты и т.д. должны быть правильно преобразованы.

Заголовки должны быть отсортированы по алфавиту.


## Уровень 4

Модуль: `level04`

Выполнить задание из уровня 3.

Создать класс с названием `Response`.

Этот класс инкапсулирует в себе составляющие
части любого http ответа:
1. код ответа
2. заголовки ответа
3. тело ответа

Нужно реализовать следующий функционал:

1. объекты класса можно создавать
1. при создании можно передать код (аргумент code),
    заголовки (аргумент headers) и тело (аргумент body).
1. если код не указан, то по умолчанию - 200
1. при преобразовании объекта ответа в строку
    должен получиться правильный http response,
    в правильном формате:
    
    ```python
    resp = Response()
    assert str(resp) == "правильный http response"
    ```


## Уровень 5

Модуль: `level05`

Выполнить задание из уровня 4.

Создать класс с названием `Server`.

Это будет симулятор веб-сервера.

При создании объекта надо будет указать хост,
на котором сервер будет запускаться.
Это будет строка, аргумент `host`.

У сервера будет метод `add_handler`, его аргументы - путь (строка) и обработчик (функция).

При вызове этого метода сервер должен будет каким-то образом
связать путь и обработчик.

Функции-обработчики будет писать тот, кто будет пользоваться сервером.

У сервера будет метод `serve`, его аргумент - некий URL.

При вызове метода `serve` сервер распарсит переданный URL,
и если хост урла совпадёт с хостом, на котором работает сервер,
и путь в урле будет серверу известен - 
сервер выполнит сохранённый обработчик
и вернёт http response с результатом, который вернёт обработчик.

Результат работы `serve(url)` - строка с http response в правильном формате.

Обработчик - это какая-то функция в виде

```python
def handler(server, parsed_url) -> str:
    ...
```

То есть, вам достаточно знать, что обработчик - это некая функция,
у которой есть два аргумента: сам сервер, и тот урл (разобранный), на котором обработчик сработал.

Что с этими аргументами будет делать обработчик - его забота.

Обработчик обещает вернуть строку в результате.

Если обработчик вернул строку - то это код 200 и в ответе содержимое - результат работы обработчика.

Если обработчик сломался в процессе - то это код 500 и в ответе сообщение, что именно сломалось, содержимое ошибки.

А если хост в запросе не известен, или путь в урле неизвестен - это код 404.

Также нужно реализовать функционал перенаправлений.

В классе Server должен быть класс `Redirect`, унаследованный от `Exception`.

Если какой-то обработчик бросит его как исключение, то это - код 302.

Пример, как ваш класс будет использоваться:

```python
def handler(server, url):
    if url.scheme != "https":
        raise server.Redirect
    x = randint(0, 10)
    y = randint(0, 10)
    return f"повезло: {x}/{y} = {x/y}"

srv = Server("host.com")
srv.add_handler("/", handler)


srv.serve("http://host.com/")
# HTTP/1.1 302 Found


srv.serve("https://host.com/")
# HTTP/1.1 200 OK
#
# повезло: 1/2 = 0.5


srv.serve("https://host.com")
# HTTP/1.1 500 Internal Server Error
#
# division by zero


srv.serve("https://host.by")
# HTTP/1.1 404 Not Found
```
